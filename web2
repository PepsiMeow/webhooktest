-- RIFT AUTO FLY SCRIPT V2
-- Automatically flies to selected rifts when they spawn
-- Version 2.0 - Simplified

local P = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local VIM = game:GetService("VirtualInputManager")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local p = P.LocalPlayer

print("========================================")
print("RIFT AUTO FLY SCRIPT V2")
print("Version: 2.0")
print("========================================")

-- Settings
local scriptActive = true
local autoHatchEnabled = false
local selectedEgg = "None" -- Which egg to return to

-- Rift state tracking
local isAtRift = false
local storedPosition = nil
local storedCFrame = nil
local riftStartTime = nil
local riftDuration = 600 -- 10 minutes in seconds
local currentRift = nil
local flyingToRift = false
local returningToEgg = false
local wasAutoHatchingBeforeFlight = false

-- Flight settings
local flySpeed = 100 -- Studs per second
local heightAboveRift = 10 -- How many studs above the rift to position player

-- Available rifts and eggs
local AVAILABLE_RIFTS = {
    {name = "peppermint-chest", displayName = "ðŸŽ„ Peppermint Chest"},
    {name = "gingerbread-egg", displayName = "ðŸª Gingerbread Egg"},
    {name = "candycane-egg", displayName = "ðŸ¬ Candycane Egg"},
    {name = "yuletide-egg", displayName = "ðŸŽ… Yuletide Egg"},
    {name = "northpole-egg", displayName = "â„ï¸ Northpole Egg"},
    {name = "aurora-egg", displayName = "ðŸŒŒ Aurora Egg"},
    {name = "festive-egg", displayName = "ðŸŽ Festive Egg"}
}

local AVAILABLE_EGGS = {
    "None",
    "Gingerbread Egg",
    "Candycane Egg",
    "Yuletide Egg",
    "Northpole Egg",
    "Aurora Egg",
    "Festive Egg"
}

-- Rift selection state (which rifts to hunt)
local riftSelections = {}
for _, rift in ipairs(AVAILABLE_RIFTS) do
    riftSelections[rift.name] = true -- All enabled by default
end

-- Settings file
local SETTINGS_FILE = "rift_auto_fly_v2_settings.json"

-- Load settings
local function loadSettings()
    if not readfile or not isfile or not HttpService then
        return
    end
    
    local success = pcall(function()
        if isfile(SETTINGS_FILE) then
            local content = readfile(SETTINGS_FILE)
            if content and content ~= "" then
                local decoded = HttpService:JSONDecode(content)
                if decoded and type(decoded) == "table" then
                    if decoded.selectedEgg and type(decoded.selectedEgg) == "string" then
                        selectedEgg = decoded.selectedEgg
                    end
                    if decoded.riftSelections and type(decoded.riftSelections) == "table" then
                        riftSelections = decoded.riftSelections
                    end
                    if decoded.flySpeed and type(decoded.flySpeed) == "number" then
                        flySpeed = decoded.flySpeed
                    end
                    print("âœ“ Settings loaded")
                    return true
                end
            end
        end
    end)
    
    if not success then
        print("âš  Using default settings")
    end
end

-- Save settings
local function saveSettings()
    if not writefile or not HttpService then
        return
    end
    
    pcall(function()
        local settings = {
            selectedEgg = selectedEgg,
            riftSelections = riftSelections,
            flySpeed = flySpeed
        }
        local encoded = HttpService:JSONEncode(settings)
        writefile(SETTINGS_FILE, encoded)
    end)
end

-- Get egg position by name
local function getEggPosition(eggName)
    local success, position = pcall(function()
        -- Look for eggs in workspace
        if workspace:FindFirstChild("Eggs") then
            local egg = workspace.Eggs:FindFirstChild(eggName)
            if egg and egg:FindFirstChild("Prompt") then
                return egg.Prompt.Position
            end
        end
        
        -- Alternative: look in Rendered folder
        if workspace:FindFirstChild("Rendered") and workspace.Rendered:FindFirstChild("Eggs") then
            local egg = workspace.Rendered.Eggs:FindFirstChild(eggName)
            if egg and egg:FindFirstChild("Prompt") then
                return egg.Prompt.Position
            elseif egg and egg:FindFirstChild("Root") then
                return egg.Root.Position
            end
        end
        
        return nil
    end)
    
    if success and position then
        return position
    end
    
    return nil
end

-- Disable/Enable character collision
local function setCollision(enabled)
    pcall(function()
        if p.Character then
            for _, part in pairs(p.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = enabled
                end
            end
        end
    end)
end

-- Smooth fly to position
local function flyToPosition(targetPos, onArrival)
    local char = p.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then
        print("âœ— No character found")
        return
    end
    
    local hrp = char.HumanoidRootPart
    local startPos = hrp.Position
    local distance = (targetPos - startPos).Magnitude
    local duration = distance / flySpeed
    
    print("ðŸš€ Flying to position... (Distance: " .. math.floor(distance) .. " studs, ETA: " .. math.floor(duration) .. "s)")
    
    -- Disable collision
    setCollision(false)
    
    -- Create a BodyPosition to move the character
    local bodyPos = Instance.new("BodyPosition")
    bodyPos.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyPos.Position = targetPos
    bodyPos.P = 10000
    bodyPos.D = 500
    bodyPos.Parent = hrp
    
    -- Create a BodyGyro to keep character upright
    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    bodyGyro.CFrame = hrp.CFrame
    bodyGyro.P = 10000
    bodyGyro.Parent = hrp
    
    -- Wait until we arrive (with timeout)
    local startTime = tick()
    local timeout = duration * 2 + 10
    
    spawn(function()
        while (hrp.Position - targetPos).Magnitude > 5 and (tick() - startTime) < timeout do
            task.wait(0.1)
        end
        
        -- Clean up
        bodyPos:Destroy()
        bodyGyro:Destroy()
        
        -- Lock position at destination
        local anchorPos = Instance.new("BodyPosition")
        anchorPos.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        anchorPos.Position = targetPos
        anchorPos.P = 50000
        anchorPos.D = 1000
        anchorPos.Name = "RiftAnchor"
        anchorPos.Parent = hrp
        
        local anchorGyro = Instance.new("BodyGyro")
        anchorGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        anchorGyro.CFrame = CFrame.new(targetPos, targetPos + Vector3.new(0, 0, -1))
        anchorGyro.P = 50000
        anchorGyro.Name = "RiftAnchorGyro"
        anchorGyro.Parent = hrp
        
        print("âœ“ Arrived at destination")
        
        if onArrival then
            onArrival()
        end
    end)
end

-- Start auto hatch
local function startAutoHatch()
    if autoHatchEnabled then
        return -- Already running
    end
    
    autoHatchEnabled = true
    print("âœ“ Auto Hatch started")
    
    spawn(function()
        while autoHatchEnabled and scriptActive do
            VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.05)
            VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            task.wait(0.35) -- 0.4s total interval
        end
    end)
end

-- Stop auto hatch
local function stopAutoHatch()
    if not autoHatchEnabled then
        return -- Already stopped
    end
    
    autoHatchEnabled = false
    print("âœ“ Auto Hatch stopped")
end

-- Return to stored position or selected egg
local function returnToEgg()
    returningToEgg = true
    print("ðŸ”™ Returning to egg...")
    
    -- Stop auto hatch first
    stopAutoHatch()
    
    -- Remove anchor
    pcall(function()
        local char = p.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local hrp = char.HumanoidRootPart
            if hrp:FindFirstChild("RiftAnchor") then
                hrp.RiftAnchor:Destroy()
            end
            if hrp:FindFirstChild("RiftAnchorGyro") then
                hrp.RiftAnchorGyro:Destroy()
            end
        end
    end)
    
    -- Determine where to return
    local returnPos = storedPosition
    
    -- If user selected a specific egg, try to get its position
    if selectedEgg ~= "None" then
        local eggPos = getEggPosition(selectedEgg)
        if eggPos then
            print("ðŸ“ Returning to selected egg: " .. selectedEgg)
            returnPos = eggPos
        end
    end
    
    if not returnPos then
        print("âœ— No return position available")
        setCollision(true)
        isAtRift = false
        currentRift = nil
        flyingToRift = false
        returningToEgg = false
        return
    end
    
    flyToPosition(returnPos, function()
        -- Re-enable collision
        setCollision(true)
        
        -- Reset state
        isAtRift = false
        currentRift = nil
        flyingToRift = false
        returningToEgg = false
        riftStartTime = nil
        
        print("âœ“ Returned to egg")
        
        -- Re-enable auto hatch if it was on before
        if wasAutoHatchingBeforeFlight then
            startAutoHatch()
        end
    end)
end

-- Handle rift spawn
local function handleRiftSpawn(rift)
    if isAtRift or flyingToRift or returningToEgg then
        print("âš  Already at a rift, ignoring: " .. rift.Name)
        return
    end
    
    -- Check if this rift is selected
    local riftName = string.lower(rift.Name)
    if not riftSelections[riftName] then
        print("â­ Rift not selected, ignoring: " .. rift.Name)
        return
    end
    
    -- Debug: Print rift structure
    print("ðŸ” DEBUG - Rift Structure:")
    print("   Name: " .. rift.Name)
    print("   ClassName: " .. rift.ClassName)
    print("   Children:")
    pcall(function()
        for _, child in ipairs(rift:GetChildren()) do
            print("      - " .. child.Name .. " (" .. child.ClassName .. ")")
            -- Print grandchildren for Models
            if child:IsA("Model") or child:IsA("Folder") then
                for _, grandchild in ipairs(child:GetChildren()) do
                    print("         - " .. grandchild.Name .. " (" .. grandchild.ClassName .. ")")
                end
            end
        end
    end)
    
    -- Try to get PrimaryPart or PivotPosition
    pcall(function()
        if rift:IsA("Model") then
            if rift.PrimaryPart then
                print("   PrimaryPart: " .. rift.PrimaryPart.Name .. " at " .. tostring(rift.PrimaryPart.Position))
            end
            print("   PivotPosition: " .. tostring(rift:GetPivot().Position))
        end
    end)
    
    -- Get rift type
    local riftType = nil
    pcall(function()
        riftType = rift:GetAttribute("Type")
        if riftType then
            print("   Type attribute: " .. riftType)
        end
    end)
    
    -- Get rift position
    local riftPos = nil
    pcall(function()
        -- Method 1: Display (works for ALL rift types based on game code)
        if rift:FindFirstChild("Display") then
            if rift.Display:IsA("BasePart") then
                riftPos = rift.Display.Position + Vector3.new(0, heightAboveRift, 0)
                print("   âœ“ Using Display.Position: " .. tostring(riftPos))
                return
            end
        end
        
        -- Method 2: Chest (for Type="Chest")
        if rift:FindFirstChild("Chest") then
            if rift.Chest:IsA("BasePart") then
                riftPos = rift.Chest.Position + Vector3.new(0, heightAboveRift, 0)
                print("   âœ“ Using Chest.Position: " .. tostring(riftPos))
                return
            elseif rift.Chest:FindFirstChild("Prompt") and rift.Chest.Prompt:IsA("BasePart") then
                riftPos = rift.Chest.Prompt.Position + Vector3.new(0, heightAboveRift, 0)
                print("   âœ“ Using Chest.Prompt.Position: " .. tostring(riftPos))
                return
            end
        end
        
        -- Method 3: Gift (for Type="Gift")
        if rift:FindFirstChild("Gift") then
            if rift.Gift:IsA("BasePart") then
                riftPos = rift.Gift.Position + Vector3.new(0, heightAboveRift, 0)
                print("   âœ“ Using Gift.Position: " .. tostring(riftPos))
                return
            elseif rift.Gift:FindFirstChild("Prompt") and rift.Gift.Prompt:IsA("BasePart") then
                riftPos = rift.Gift.Prompt.Position + Vector3.new(0, heightAboveRift, 0)
                print("   âœ“ Using Gift.Prompt.Position: " .. tostring(riftPos))
                return
            end
        end
        
        -- Method 4: Model PivotPosition (modern Roblox)
        if rift:IsA("Model") then
            local pivot = rift:GetPivot()
            if pivot then
                riftPos = pivot.Position + Vector3.new(0, heightAboveRift, 0)
                print("   âœ“ Using PivotPosition: " .. tostring(riftPos))
                return
            end
        end
        
        -- Method 5: PrimaryPart
        if rift:IsA("Model") and rift.PrimaryPart then
            riftPos = rift.PrimaryPart.Position + Vector3.new(0, heightAboveRift, 0)
            print("   âœ“ Using PrimaryPart.Position: " .. tostring(riftPos))
            return
        end
        
        -- Method 6: Direct BasePart
        if rift:IsA("BasePart") then
            riftPos = rift.Position + Vector3.new(0, heightAboveRift, 0)
            print("   âœ“ Using direct Position: " .. tostring(riftPos))
            return
        end
    end)
    
    if not riftPos then
        print("âœ— Could not determine rift position")
        print("   Please share the debug output above!")
        return
    end
    
    print("========================================")
    print("ðŸŽ¯ SELECTED RIFT DETECTED!")
    print("   Name: " .. rift.Name)
    print("   Position: " .. tostring(riftPos))
    print("========================================")
    
    -- Store current position
    local char = p.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        storedPosition = char.HumanoidRootPart.Position
        storedCFrame = char.HumanoidRootPart.CFrame
        print("ðŸ’¾ Stored current position: " .. tostring(storedPosition))
    else
        print("âœ— Could not store current position")
        return
    end
    
    -- Store auto hatch state and stop it
    wasAutoHatchingBeforeFlight = autoHatchEnabled
    if autoHatchEnabled then
        stopAutoHatch()
        print("â¸ Auto Hatch disabled for flight")
    end
    
    -- Set state
    flyingToRift = true
    currentRift = rift
    
    -- Fly to rift
    flyToPosition(riftPos, function()
        flyingToRift = false
        isAtRift = true
        riftStartTime = tick()
        
        print("========================================")
        print("âœ… ARRIVED AT RIFT!")
        print("   Starting auto hatch for 10 minutes")
        print("========================================")
        
        -- Start auto hatch at rift
        startAutoHatch()
        
        -- Monitor rift duration
        spawn(function()
            local despawnTime = nil
            
            -- Try to get despawn time from rift attribute
            pcall(function()
                if currentRift then
                    despawnTime = currentRift:GetAttribute("DespawnAt")
                end
            end)
            
            -- Wait for rift to despawn or 10 minutes
            if despawnTime then
                local timeToWait = despawnTime - workspace:GetServerTimeNow()
                print("â± Rift will despawn in " .. math.floor(timeToWait) .. " seconds")
                task.wait(math.min(timeToWait, riftDuration))
            else
                print("â± Waiting 10 minutes at rift")
                task.wait(riftDuration)
            end
            
            -- Check if we're still at the rift (user might have cancelled)
            if isAtRift then
                print("â° Rift time expired, returning to egg")
                returnToEgg()
            end
        end)
    end)
end

-- Monitor workspace.Rendered.Rifts for new rifts
local function setupRiftMonitoring()
    local monitoredFolders = {}
    
    -- Function to set up monitoring on a folder
    local function monitorFolder(folder, folderPath)
        if monitoredFolders[folder] then
            return
        end
        
        print("âœ“ Monitoring: " .. folderPath)
        monitoredFolders[folder] = true
        
        -- Check existing rifts
        for _, rift in ipairs(folder:GetChildren()) do
            print("   Found existing rift: " .. rift.Name)
        end
        
        -- Monitor for new rifts
        folder.ChildAdded:Connect(function(rift)
            print("ðŸŽ„ NEW RIFT SPAWNED: " .. rift.Name)
            task.wait(1) -- Small delay to ensure rift is fully loaded
            handleRiftSpawn(rift)
        end)
    end
    
    -- Try multiple possible locations
    local success = pcall(function()
        -- Location 1: workspace.Rendered.Rifts
        if workspace:FindFirstChild("Rendered") then
            local rendered = workspace.Rendered
            
            local riftsFolder = rendered:FindFirstChild("Rifts")
            if riftsFolder then
                monitorFolder(riftsFolder, "workspace.Rendered.Rifts")
            else
                print("âš  workspace.Rendered.Rifts not found yet, monitoring for it...")
                rendered.ChildAdded:Connect(function(child)
                    if child.Name == "Rifts" and not monitoredFolders[child] then
                        print("âœ“ Rifts folder appeared!")
                        monitorFolder(child, "workspace.Rendered.Rifts")
                    end
                end)
            end
        else
            print("âš  workspace.Rendered not found, monitoring for it...")
            workspace.ChildAdded:Connect(function(child)
                if child.Name == "Rendered" then
                    print("âœ“ Rendered folder appeared!")
                    task.wait(1)
                    
                    local riftsFolder = child:FindFirstChild("Rifts")
                    if riftsFolder then
                        monitorFolder(riftsFolder, "workspace.Rendered.Rifts")
                    else
                        child.ChildAdded:Connect(function(subchild)
                            if subchild.Name == "Rifts" and not monitoredFolders[subchild] then
                                monitorFolder(subchild, "workspace.Rendered.Rifts")
                            end
                        end)
                    end
                end
            end)
        end
        
        -- Location 2: workspace.Rifts (alternative)
        if workspace:FindFirstChild("Rifts") then
            monitorFolder(workspace.Rifts, "workspace.Rifts")
        else
            workspace.ChildAdded:Connect(function(child)
                if child.Name == "Rifts" and not monitoredFolders[child] then
                    print("âœ“ Found alternative rift location!")
                    monitorFolder(child, "workspace.Rifts")
                end
            end)
        end
        
        print("âœ“ Rift monitoring active")
    end)
    
    if not success then
        print("âœ— Failed to setup rift monitoring")
    end
end

-- Cancel current rift operation
local function cancelRiftOperation()
    if not isAtRift and not flyingToRift and not returningToEgg then
        print("âš  No active rift operation to cancel")
        return
    end
    
    print("ðŸ›‘ Cancelling rift operation...")
    
    -- Stop auto hatch
    stopAutoHatch()
    
    -- Remove flight/anchor objects
    pcall(function()
        local char = p.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local hrp = char.HumanoidRootPart
            for _, obj in ipairs(hrp:GetChildren()) do
                if obj:IsA("BodyPosition") or obj:IsA("BodyGyro") then
                    obj:Destroy()
                end
            end
        end
    end)
    
    -- Re-enable collision
    setCollision(true)
    
    -- Reset state
    isAtRift = false
    currentRift = nil
    flyingToRift = false
    returningToEgg = false
    riftStartTime = nil
    
    -- Re-enable auto hatch if it was on before
    if wasAutoHatchingBeforeFlight then
        startAutoHatch()
    end
    
    print("âœ“ Rift operation cancelled")
end

-- Create GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "RiftAutoFlyGUI_V2"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Try to parent to CoreGui first, fallback to PlayerGui
local parent = nil
pcall(function()
    parent = game:GetService("CoreGui")
end)
if not parent then
    parent = p:WaitForChild("PlayerGui")
end
screenGui.Parent = parent

-- Main frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 380, 0, 520)
mainFrame.Position = UDim2.new(0.5, -190, 0.5, -260)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
mainFrame.BorderSizePixel = 2
mainFrame.BorderColor3 = Color3.fromRGB(50, 200, 50)
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = mainFrame

-- Title bar
local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 40)
titleBar.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 8)
titleCorner.Parent = titleBar

local titleBottomFix = Instance.new("Frame")
titleBottomFix.Size = UDim2.new(1, 0, 0, 8)
titleBottomFix.Position = UDim2.new(0, 0, 1, -8)
titleBottomFix.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
titleBottomFix.BorderSizePixel = 0
titleBottomFix.Parent = titleBar

local titleText = Instance.new("TextLabel")
titleText.Size = UDim2.new(1, -20, 1, 0)
titleText.Position = UDim2.new(0, 10, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "ðŸŽ„ RIFT AUTO FLY"
titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
titleText.TextSize = 18
titleText.Font = Enum.Font.GothamBold
titleText.TextXAlignment = Enum.TextXAlignment.Left
titleText.Parent = titleBar

-- Content area
local contentFrame = Instance.new("ScrollingFrame")
contentFrame.Size = UDim2.new(1, -20, 1, -60)
contentFrame.Position = UDim2.new(0, 10, 0, 50)
contentFrame.BackgroundTransparency = 1
contentFrame.ScrollBarThickness = 6
contentFrame.Parent = mainFrame

-- Auto Hatch button
local autoHatchBtn = Instance.new("TextButton")
autoHatchBtn.Size = UDim2.new(1, 0, 0, 40)
autoHatchBtn.Position = UDim2.new(0, 0, 0, 0)
autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
autoHatchBtn.Text = "Auto Hatch: OFF"
autoHatchBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
autoHatchBtn.TextSize = 16
autoHatchBtn.Font = Enum.Font.GothamBold
autoHatchBtn.BorderSizePixel = 0
autoHatchBtn.Parent = contentFrame

local autoHatchCorner = Instance.new("UICorner")
autoHatchCorner.CornerRadius = UDim.new(0, 6)
autoHatchCorner.Parent = autoHatchBtn

-- Rift selection label
local riftSelectionLabel = Instance.new("TextLabel")
riftSelectionLabel.Size = UDim2.new(1, 0, 0, 30)
riftSelectionLabel.Position = UDim2.new(0, 0, 0, 50)
riftSelectionLabel.BackgroundTransparency = 1
riftSelectionLabel.Text = "Select Rifts to Hunt:"
riftSelectionLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
riftSelectionLabel.TextSize = 14
riftSelectionLabel.Font = Enum.Font.GothamBold
riftSelectionLabel.TextXAlignment = Enum.TextXAlignment.Left
riftSelectionLabel.Parent = contentFrame

-- Create rift checkboxes
local riftCheckboxes = {}
for i, rift in ipairs(AVAILABLE_RIFTS) do
    local yPos = 80 + ((i - 1) * 40)
    
    local checkbox = Instance.new("TextButton")
    checkbox.Size = UDim2.new(1, 0, 0, 35)
    checkbox.Position = UDim2.new(0, 0, 0, yPos)
    checkbox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    checkbox.Text = "âœ“ " .. rift.displayName
    checkbox.TextColor3 = Color3.fromRGB(255, 255, 255)
    checkbox.TextSize = 13
    checkbox.Font = Enum.Font.Gotham
    checkbox.TextXAlignment = Enum.TextXAlignment.Left
    checkbox.BorderSizePixel = 0
    checkbox.Parent = contentFrame
    
    -- Add padding
    local padding = Instance.new("UIPadding")
    padding.PaddingLeft = UDim.new(0, 10)
    padding.Parent = checkbox
    
    local checkboxCorner = Instance.new("UICorner")
    checkboxCorner.CornerRadius = UDim.new(0, 6)
    checkboxCorner.Parent = checkbox
    
    -- Update initial state
    if riftSelections[rift.name] then
        checkbox.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
        checkbox.Text = "âœ“ " .. rift.displayName
    else
        checkbox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        checkbox.Text = "â˜ " .. rift.displayName
    end
    
    riftCheckboxes[rift.name] = checkbox
end

-- Egg selector
local eggSelectorLabel = Instance.new("TextLabel")
eggSelectorLabel.Size = UDim2.new(1, 0, 0, 25)
eggSelectorLabel.Position = UDim2.new(0, 0, 0, 370)
eggSelectorLabel.BackgroundTransparency = 1
eggSelectorLabel.Text = "Return to Egg:"
eggSelectorLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
eggSelectorLabel.TextSize = 14
eggSelectorLabel.Font = Enum.Font.Gotham
eggSelectorLabel.TextXAlignment = Enum.TextXAlignment.Left
eggSelectorLabel.Parent = contentFrame

local eggSelectorBtn = Instance.new("TextButton")
eggSelectorBtn.Size = UDim2.new(1, 0, 0, 35)
eggSelectorBtn.Position = UDim2.new(0, 0, 0, 400)
eggSelectorBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
eggSelectorBtn.Text = "ðŸ¥š " .. selectedEgg
eggSelectorBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
eggSelectorBtn.TextSize = 14
eggSelectorBtn.Font = Enum.Font.Gotham
eggSelectorBtn.BorderSizePixel = 0
eggSelectorBtn.Parent = contentFrame

local eggSelectorCorner = Instance.new("UICorner")
eggSelectorCorner.CornerRadius = UDim.new(0, 6)
eggSelectorCorner.Parent = eggSelectorBtn

-- Egg dropdown list (hidden by default)
local eggDropdown = Instance.new("ScrollingFrame")
eggDropdown.Size = UDim2.new(1, 0, 0, 150)
eggDropdown.Position = UDim2.new(0, 0, 0, 440)
eggDropdown.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
eggDropdown.BorderSizePixel = 1
eggDropdown.BorderColor3 = Color3.fromRGB(100, 100, 100)
eggDropdown.Visible = false
eggDropdown.ScrollBarThickness = 6
eggDropdown.Parent = contentFrame

local eggDropdownCorner = Instance.new("UICorner")
eggDropdownCorner.CornerRadius = UDim.new(0, 6)
eggDropdownCorner.Parent = eggDropdown

local eggListLayout = Instance.new("UIListLayout")
eggListLayout.SortOrder = Enum.SortOrder.LayoutOrder
eggListLayout.Padding = UDim.new(0, 2)
eggListLayout.Parent = eggDropdown

-- Populate egg dropdown
for i, eggName in ipairs(AVAILABLE_EGGS) do
    local eggOption = Instance.new("TextButton")
    eggOption.Size = UDim2.new(1, -10, 0, 30)
    eggOption.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    eggOption.Text = eggName
    eggOption.TextColor3 = Color3.fromRGB(255, 255, 255)
    eggOption.TextSize = 12
    eggOption.Font = Enum.Font.Gotham
    eggOption.BorderSizePixel = 0
    eggOption.Parent = eggDropdown
    
    local optionCorner = Instance.new("UICorner")
    optionCorner.CornerRadius = UDim.new(0, 4)
    optionCorner.Parent = eggOption
    
    eggOption.Activated:Connect(function()
        selectedEgg = eggName
        eggSelectorBtn.Text = "ðŸ¥š " .. selectedEgg
        eggDropdown.Visible = false
        saveSettings()
        print("âœ“ Selected egg: " .. selectedEgg)
    end)
end

eggDropdown.CanvasSize = UDim2.new(0, 0, 0, #AVAILABLE_EGGS * 32)

-- Update canvas size for content frame
contentFrame.CanvasSize = UDim2.new(0, 0, 0, 600)

-- Status label
local statusLabel = Instance.new("TextLabel")
statusLabel.Size = UDim2.new(1, -20, 0, 80)
statusLabel.Position = UDim2.new(0, 10, 1, -90)
statusLabel.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
statusLabel.Text = "Status: Waiting for rifts..."
statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
statusLabel.TextSize = 12
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextWrapped = true
statusLabel.BorderSizePixel = 0
statusLabel.Parent = mainFrame

local statusCorner = Instance.new("UICorner")
statusCorner.CornerRadius = UDim.new(0, 6)
statusCorner.Parent = statusLabel

-- Cancel button (only visible when at rift)
local cancelBtn = Instance.new("TextButton")
cancelBtn.Size = UDim2.new(1, -20, 0, 35)
cancelBtn.Position = UDim2.new(0, 10, 1, -90)
cancelBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
cancelBtn.Text = "ðŸ›‘ Cancel Rift Operation"
cancelBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
cancelBtn.TextSize = 14
cancelBtn.Font = Enum.Font.GothamBold
cancelBtn.BorderSizePixel = 0
cancelBtn.Visible = false
cancelBtn.Parent = mainFrame

local cancelCorner = Instance.new("UICorner")
cancelCorner.CornerRadius = UDim.new(0, 6)
cancelCorner.Parent = cancelBtn

-- Update status display
local function updateStatus()
    spawn(function()
        while scriptActive do
            local statusText = "Status: "
            if flyingToRift then
                statusText = statusText .. "ðŸš€ Flying to rift..."
            elseif isAtRift then
                local timeElapsed = math.floor(tick() - riftStartTime)
                local timeRemaining = riftDuration - timeElapsed
                statusText = statusText .. "ðŸŽ¯ At rift (" .. math.floor(timeRemaining / 60) .. "m " .. (timeRemaining % 60) .. "s left)"
            elseif returningToEgg then
                statusText = statusText .. "ðŸ”™ Returning to egg..."
            else
                statusText = statusText .. "â³ Waiting for selected rifts..."
            end
            
            statusLabel.Text = statusText
            
            -- Show/hide cancel button
            cancelBtn.Visible = (flyingToRift or isAtRift or returningToEgg)
            statusLabel.Visible = not cancelBtn.Visible
            
            task.wait(1)
        end
    end)
end

-- Button handlers
autoHatchBtn.Activated:Connect(function()
    if not scriptActive then return end
    
    -- Don't allow manual toggle during rift operations
    if flyingToRift or returningToEgg then
        print("âš  Cannot toggle auto hatch during flight")
        return
    end
    
    if autoHatchEnabled then
        stopAutoHatch()
        autoHatchBtn.Text = "Auto Hatch: OFF"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    else
        startAutoHatch()
        autoHatchBtn.Text = "Auto Hatch: ON"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    end
end)

-- Rift checkbox handlers
for riftName, checkbox in pairs(riftCheckboxes) do
    checkbox.Activated:Connect(function()
        if not scriptActive then return end
        
        riftSelections[riftName] = not riftSelections[riftName]
        
        -- Find display name
        local displayName = riftName
        for _, rift in ipairs(AVAILABLE_RIFTS) do
            if rift.name == riftName then
                displayName = rift.displayName
                break
            end
        end
        
        if riftSelections[riftName] then
            checkbox.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
            checkbox.Text = "âœ“ " .. displayName
        else
            checkbox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
            checkbox.Text = "â˜ " .. displayName
        end
        
        saveSettings()
        print("âœ“ Rift " .. riftName .. ": " .. (riftSelections[riftName] and "ON" or "OFF"))
    end)
end

eggSelectorBtn.Activated:Connect(function()
    eggDropdown.Visible = not eggDropdown.Visible
end)

cancelBtn.Activated:Connect(function()
    cancelRiftOperation()
end)

-- Initialize
loadSettings()

-- Update button states from loaded settings
for riftName, checkbox in pairs(riftCheckboxes) do
    local displayName = riftName
    for _, rift in ipairs(AVAILABLE_RIFTS) do
        if rift.name == riftName then
            displayName = rift.displayName
            break
        end
    end
    
    if riftSelections[riftName] then
        checkbox.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
        checkbox.Text = "âœ“ " .. displayName
    else
        checkbox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        checkbox.Text = "â˜ " .. displayName
    end
end

setupRiftMonitoring()
updateStatus()

print("========================================")
print("âœ“ Rift Auto Fly V2 loaded!")
print("âœ“ GUI created and ready")
print("========================================")
print("Selected rifts:")
for riftName, enabled in pairs(riftSelections) do
    if enabled then
        print("  âœ“ " .. riftName)
    end
end
print("Return egg: " .. selectedEgg)
print("========================================")

