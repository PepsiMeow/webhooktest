-- Test file for remote event hooking in Delta Executor Mobile
-- VERSION 4.0 - COMPLETELY DIFFERENT APPROACH
-- This will help us debug why events aren't being captured

local P = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local p = P.LocalPlayer
local newcclosure = newcclosure or function(func) return func end

-- IMMEDIATE VERSION CHECK - This prints immediately to verify version
print("========================================")
print("REMOTE HOOK TEST - VERSION 4.0")
print("NEW APPROACH: Direct storage")
print("========================================")
game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "Remote Hook Test v4.0",
    Text = "New approach - direct storage!",
    Duration = 5
})

wait(1)

-- Webhook setup
local WEBHOOK = "https://discord.com/api/webhooks/1227328649322168391/2SdD38qqsMjyktorFtdOLO7p9yN_RK_VdVocfiuT-SxRVKX1t5dMEw3STYxfSWCz7IeQ"
local BATCH_SIZE = 10

-- Create a simple global storage table - use a unique name
_G._RH_Events = _G._RH_Events or {}
local eventStorage = _G._RH_Events

-- HTTP library detection (same as main script)
local httpLib = nil
local httpLibName = ""
if delta and delta.request then
    httpLib = function(url, method, headers, body)
        local success, res, err = pcall(function()
            return delta.request({Url = url, Method = method, Headers = headers or {}, Body = body})
        end)
        if success and res then
            local status = res.StatusCode or (res.Success and 200 or 0)
            local body = res.Body or ""
            local ok = res.Success or status == 200 or status == 204
            return ok, body, status
        end
        return false, err or "Request exception", 0
    end
    httpLibName = "delta.request"
elseif request then
    httpLib = function(url, method, headers, body)
        local success, res, err = pcall(function()
            return request({Url = url, Method = method, Headers = headers or {}, Body = body})
        end)
        if success and res then
            local status = res.StatusCode or (res.Success and 200 or (res.success and 200 or 0))
            local body = res.Body or res.body or ""
            local ok = res.Success or res.success or status == 200 or status == 204
            return ok, body, status
        end
        return false, err or "Request exception", 0
    end
    httpLibName = "request"
end

-- JSON encoder
local function jsonEncode(value, depth)
    depth = depth or 0
    if depth > 10 then return '"max_depth"' end
    local vType = type(value)
    if vType == "string" then
        local escaped = string.gsub(value, "\\", "\\\\")
        escaped = string.gsub(escaped, "\"", "\\\"")
        escaped = string.gsub(escaped, "\n", "\\n")
        escaped = string.gsub(escaped, "\r", "\\r")
        escaped = string.gsub(escaped, "\t", "\\t")
        return string.format("%q", escaped)
    elseif vType == "number" then
        return tostring(value)
    elseif vType == "boolean" then
        return value and "true" or "false"
    elseif vType == "nil" then
        return "null"
    elseif vType == "table" then
        local isArray = true
        local maxIndex = 0
        for k in pairs(value) do
            if type(k) ~= "number" or k < 1 or k ~= math.floor(k) then
                isArray = false
                break
            end
            if k > maxIndex then maxIndex = k end
        end
        if isArray and maxIndex > 0 then
            local parts = {}
            for i = 1, maxIndex do
                table.insert(parts, jsonEncode(value[i], depth + 1))
            end
            return "[" .. table.concat(parts, ",") .. "]"
        else
            local parts = {}
            for k, v in pairs(value) do
                local keyStr = type(k) == "string" and string.format("%q", k) or "[" .. tostring(k) .. "]"
                table.insert(parts, keyStr .. ":" .. jsonEncode(v, depth + 1))
            end
            return "{" .. table.concat(parts, ",") .. "}"
        end
    else
        return string.format("%q", tostring(value))
    end
end

-- Send batched events to webhook
local function sendBatchWebhook(events)
    addLog("sendBatchWebhook called with " .. #events .. " events")
    
    if not httpLib then
        addLog("ERROR: HTTP library not available!")
        addLog("HTTP Lib Name: " .. (httpLibName ~= "" and httpLibName or "NOT FOUND"))
        return
    end
    if #events == 0 then
        addLog("ERROR: No events to send!")
        return
    end
    
    spawn(function()
        addLog("Preparing webhook payload...")
        local content = "**=== EVENT BATCH ===**\n"
        content = content .. "Total Events: " .. #events .. "\n"
        content = content .. "Time: " .. os.date("%Y-%m-%d %X") .. "\n\n"
        
        for i, event in ipairs(events) do
            content = content .. "**Event #" .. i .. "** (" .. event.time .. ")\n"
            content = content .. "```\n"
            content = content .. event.data
            content = content .. "\n```\n\n"
        end
        
        local payload = {["content"] = content}
        addLog("Encoding JSON...")
        local jsonPayload = jsonEncode(payload)
        local headers = {["Content-Type"] = "application/json"}
        
        addLog("Sending to webhook: " .. string.sub(WEBHOOK, 1, 50) .. "...")
        local success, response, status = httpLib(WEBHOOK, "POST", headers, jsonPayload)
        
        if success and (status == 200 or status == 204) then
            addLog("âœ“ Sent batch of " .. #events .. " events to Discord (Status: " .. tostring(status) .. ")")
            if statusLabel then
                statusLabel.Text = "Events: " .. hookCount .. " | Pending: 0/" .. BATCH_SIZE .. " (Sent!)"
            end
        else
            addLog("âœ— Webhook failed!")
            addLog("  Success: " .. tostring(success))
            addLog("  Status: " .. tostring(status))
            addLog("  Response: " .. tostring(response or "nil"))
            if statusLabel then
                statusLabel.Text = "Events: " .. hookCount .. " | Pending: 0/" .. BATCH_SIZE .. " (FAILED!)"
            end
        end
    end)
end

-- Create a simple GUI for testing
local g = Instance.new("ScreenGui")
g.Name = "RemoteHookTest"
g.Parent = p.PlayerGui

local f = Instance.new("Frame")
f.Size = UDim2.new(0, 380, 0, 350)
f.Position = UDim2.new(0.5, -190, 0.5, -175)
f.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
f.BorderSizePixel = 0
f.Parent = g

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 40)
title.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
title.Text = "Remote Hook Test v4.0 - NEW APPROACH"
title.TextColor3 = Color3.fromRGB(50, 255, 50)
title.TextSize = 15
title.Font = Enum.Font.GothamBold
title.Parent = f

local logDisplay = Instance.new("TextLabel")
logDisplay.Size = UDim2.new(0, 360, 0, 200)
logDisplay.Position = UDim2.new(0.5, -180, 0, 50)
logDisplay.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
logDisplay.BorderSizePixel = 0
logDisplay.Text = "Click 'Find Remote' to start..."
logDisplay.TextColor3 = Color3.fromRGB(150, 200, 255)
logDisplay.TextSize = 10
logDisplay.Font = Enum.Font.Gotham
logDisplay.TextWrapped = true
logDisplay.TextXAlignment = Enum.TextXAlignment.Left
logDisplay.TextYAlignment = Enum.TextYAlignment.Top
logDisplay.Parent = f

local function addLog(text)
    local current = logDisplay.Text or ""
    local lines = {}
    for line in string.gmatch(current, "([^\n]+)") do
        table.insert(lines, line)
    end
    table.insert(lines, text)
    while #lines > 20 do
        table.remove(lines, 1)
    end
    logDisplay.Text = table.concat(lines, "\n")
end

local remoteEvent = nil
local originalFireClient = nil
local hookCount = 0

local function findRemote()
    addLog("=== Finding Remote Event ===")
    
    local success, remote = pcall(function()
        return RS:FindFirstChild("Shared") 
            and RS.Shared:FindFirstChild("Framework") 
            and RS.Shared.Framework:FindFirstChild("Network") 
            and RS.Shared.Framework.Network:FindFirstChild("Remote") 
            and RS.Shared.Framework.Network.Remote:FindFirstChild("RemoteEvent")
    end)
    
    if success and remote then
        remoteEvent = remote
        addLog("âœ“ Found RemoteEvent!")
        addLog("Path: " .. remote:GetFullName())
        addLog("Class: " .. remote.ClassName)
        
        -- Check if it has FireClient method
        if remote.FireClient then
            addLog("âœ“ FireClient method exists")
            addLog("FireClient type: " .. type(remote.FireClient))
        else
            addLog("âœ— FireClient method NOT found")
        end
        
        -- Check if it has OnClientEvent
        if remote.OnClientEvent then
            addLog("âœ“ OnClientEvent exists")
        else
            addLog("âœ— OnClientEvent NOT found")
        end
        
        return true
    else
        addLog("âœ— RemoteEvent NOT found")
        addLog("Checking ReplicatedStorage structure...")
        
        -- Try to find any RemoteEvent
        local allRemotes = {}
        for _, obj in pairs(RS:GetDescendants()) do
            if obj:IsA("RemoteEvent") then
                table.insert(allRemotes, obj:GetFullName())
            end
        end
        
        if #allRemotes > 0 then
            addLog("Found " .. #allRemotes .. " RemoteEvent(s):")
            for i, path in ipairs(allRemotes) do
                addLog("  " .. i .. ". " .. path)
            end
        else
            addLog("No RemoteEvents found in ReplicatedStorage")
        end
        
        return false
    end
end

local function hookFireClient()
    if not remoteEvent then
        addLog("ERROR: RemoteEvent not found! Click 'Find Remote' first.")
        return false
    end
    
    if originalFireClient then
        addLog("Already hooked! Unhooking first...")
        remoteEvent.FireClient = originalFireClient
        originalFireClient = nil
    end
    
    addLog("\n=== Attempting to Hook FireClient ===")
    
    local success, err = pcall(function()
        originalFireClient = remoteEvent.FireClient
        addLog("âœ“ Saved original FireClient")
        addLog("Original type: " .. type(originalFireClient))
        
        remoteEvent.FireClient = newcclosure(function(self, ...)
            hookCount = hookCount + 1
            local args = {...}
            
            -- DIRECT STORAGE - Store immediately to global table
            local eventTime = os.date("%X")
            local eventData = {
                time = eventTime,
                hookNumber = hookCount,
                argsCount = #args
            }
            
            -- Create a detailed string representation
            local eventStr = "\n=== EVENT #" .. hookCount .. " ===\n"
            eventStr = eventStr .. "Time: " .. eventTime .. "\n"
            eventStr = eventStr .. "Args count: " .. #args .. "\n\n"
            
            local function serializeValue(v, depth, maxDepth, indent)
                depth = depth or 0
                maxDepth = maxDepth or 5
                indent = indent or ""
                local nextIndent = indent .. "  "
                
                if depth > maxDepth then
                    return "[Max Depth Reached]"
                end
                
                local vType = type(v)
                if vType == "string" then
                    return string.format("%q", v)
                elseif vType == "number" or vType == "boolean" then
                    return tostring(v)
                elseif vType == "nil" then
                    return "nil"
                elseif vType == "table" then
                    -- Check if table is empty
                    local hasItems = false
                    for _ in pairs(v) do
                        hasItems = true
                        break
                    end
                    if not hasItems then
                        return "{}"
                    end
                    
                    local parts = {"{"}
                    local isArray = true
                    local maxIndex = 0
                    local keyCount = 0
                    
                    -- First pass: check if it's an array and count keys
                    for k in pairs(v) do
                        keyCount = keyCount + 1
                        if type(k) ~= "number" or k < 1 or k ~= math.floor(k) then
                            isArray = false
                        end
                        if type(k) == "number" and k > maxIndex then
                            maxIndex = k
                        end
                    end
                    
                    if isArray and maxIndex > 0 then
                        -- Array format
                        for i = 1, math.min(maxIndex, 50) do
                            if v[i] ~= nil then
                                table.insert(parts, nextIndent .. "[" .. i .. "] = " .. serializeValue(v[i], depth + 1, maxDepth, nextIndent))
                            end
                        end
                        if maxIndex > 50 then
                            table.insert(parts, nextIndent .. "... (" .. (maxIndex - 50) .. " more items)")
                        end
                    else
                        -- Dictionary format - show all keys
                        local shown = 0
                        for k, val in pairs(v) do
                            shown = shown + 1
                            if shown <= 100 then
                                local keyStr
                                if type(k) == "string" then
                                    keyStr = "[" .. string.format("%q", k) .. "]"
                                else
                                    keyStr = "[" .. tostring(k) .. "]"
                                end
                                local valStr = serializeValue(val, depth + 1, maxDepth, nextIndent)
                                table.insert(parts, nextIndent .. keyStr .. " = " .. valStr)
                            end
                        end
                        if shown > 100 then
                            table.insert(parts, nextIndent .. "... (" .. (shown - 100) .. " more keys)")
                        end
                    end
                    table.insert(parts, indent .. "}")
                    return table.concat(parts, "\n")
                else
                    return "[" .. vType .. ": " .. tostring(v) .. "]"
                end
            end
            
            for i, arg in ipairs(args) do
                local argType = type(arg)
                eventStr = eventStr .. "Arg[" .. i .. "] (type: " .. argType .. "):\n"
                
                if argType == "string" then
                    eventStr = eventStr .. "  Value: " .. arg .. "\n"
                elseif argType == "number" then
                    eventStr = eventStr .. "  Value: " .. tostring(arg) .. "\n"
                elseif argType == "table" then
                    -- First, show basic info
                    local keyCount = 0
                    local arrayCount = 0
                    for k in pairs(arg) do
                        keyCount = keyCount + 1
                        if type(k) == "number" then
                            arrayCount = arrayCount + 1
                        end
                    end
                    eventStr = eventStr .. "  Total keys: " .. keyCount .. " (array elements: " .. arrayCount .. ")\n"
                    
                    -- Show all keys first
                    local keys = {}
                    for k in pairs(arg) do
                        table.insert(keys, tostring(k))
                    end
                    if #keys <= 20 then
                        eventStr = eventStr .. "  Keys: " .. table.concat(keys, ", ") .. "\n"
                    else
                        eventStr = eventStr .. "  Keys (first 20): " .. table.concat({table.unpack(keys, 1, 20)}, ", ") .. "...\n"
                    end
                    
                    -- Now serialize the full table - force deep serialization
                    eventStr = eventStr .. "  Full structure:\n"
                    local serialized = serializeValue(arg, 0, 6, "  ")
                    eventStr = eventStr .. serialized .. "\n"
                    
                    -- Special handling for Pets table - try accessing as array first
                    if arg.Pets then
                        eventStr = eventStr .. "  === PETS TABLE DETAILS ===\n"
                        local petsTable = arg.Pets
                        if type(petsTable) == "table" then
                            -- Try accessing as numeric array first (most common)
                            local maxPetIndex = 0
                            for i = 1, 20 do
                                if petsTable[i] ~= nil then
                                    maxPetIndex = i
                                end
                            end
                            
                            if maxPetIndex > 0 then
                                eventStr = eventStr .. "  Pets array with " .. maxPetIndex .. " elements\n"
                                for i = 1, maxPetIndex do
                                    local petData = petsTable[i]
                                    if petData then
                                        eventStr = eventStr .. "  Pet[" .. i .. "]:\n"
                                        if type(petData) == "table" then
                                            -- Try accessing Pet.Name directly
                                            if petData.Pet then
                                                local pet = petData.Pet
                                                if type(pet) == "table" then
                                                    eventStr = eventStr .. "    Name: " .. tostring(pet.Name or "nil") .. "\n"
                                                    eventStr = eventStr .. "    Shiny: " .. tostring(pet.Shiny or "nil") .. "\n"
                                                    eventStr = eventStr .. "    Mythic: " .. tostring(pet.Mythic or "nil") .. "\n"
                                                    eventStr = eventStr .. "    Type: " .. tostring(pet.Type or "nil") .. "\n"
                                                else
                                                    eventStr = eventStr .. "    Pet: " .. tostring(pet) .. "\n"
                                                end
                                            end
                                            eventStr = eventStr .. "    Deleted: " .. tostring(petData.Deleted or "nil") .. "\n"
                                            eventStr = eventStr .. "    New: " .. tostring(petData.New or "nil") .. "\n"
                                        else
                                            eventStr = eventStr .. "    Type: " .. type(petData) .. " = " .. tostring(petData) .. "\n"
                                        end
                                    end
                                end
                            else
                                -- Try pairs if array access doesn't work
                                eventStr = eventStr .. "  Trying pairs() access...\n"
                                local petCount = 0
                                for k, petData in pairs(petsTable) do
                                    petCount = petCount + 1
                                    eventStr = eventStr .. "  Pet[" .. tostring(k) .. "]:\n"
                                    if type(petData) == "table" then
                                        if petData.Pet and type(petData.Pet) == "table" then
                                            eventStr = eventStr .. "    Name: " .. tostring(petData.Pet.Name or "nil") .. "\n"
                                        end
                                    end
                                    if petCount >= 10 then break end
                                end
                            end
                        else
                            eventStr = eventStr .. "  Pets is not a table! Type: " .. type(petsTable) .. "\n"
                        end
                    end
                elseif argType == "Instance" then
                    if arg:IsA("Player") then
                        eventStr = eventStr .. "  Player: " .. arg.Name .. "\n"
                    else
                        eventStr = eventStr .. "  Instance: " .. arg.ClassName .. "\n"
                    end
                else
                    eventStr = eventStr .. "  " .. tostring(arg) .. "\n"
                end
                eventStr = eventStr .. "\n"
            end
            
            eventStr = eventStr .. "=== END EVENT ===\n"
            
            -- Complete event data
            eventData.data = eventStr
            
            -- DIRECT INSERT - Use global storage directly, no intermediate variables
            _G._RH_Events[#_G._RH_Events + 1] = eventData
            
            -- Verify storage immediately
            local storedCount = #_G._RH_Events
            addLog("STORED: Event #" .. hookCount .. ", Total: " .. storedCount)
            print("EVENT STORED: #" .. hookCount .. ", Count: " .. storedCount)
            
            -- Update status
            local storedCount = #_G._RH_Events
            if statusLabel then
                statusLabel.Text = "Events: " .. hookCount .. " | Pending: " .. storedCount .. "/" .. BATCH_SIZE
            end
            
            -- Add to log display (truncated)
            local logLines = {}
            for line in string.gmatch(eventStr, "([^\n]+)") do
                table.insert(logLines, line)
            end
            for i = 1, math.min(8, #logLines) do
                addLog(logLines[i])
            end
            if #logLines > 8 then
                addLog("... (stored for webhook)")
            end
            
            addLog("Pending: " .. storedCount .. "/" .. BATCH_SIZE)
            
            -- Send batch if we have enough events
            if storedCount >= BATCH_SIZE then
                addLog("\n=== Auto-sending batch ===")
                local batchToSend = {}
                for i = 1, storedCount do
                    batchToSend[i] = _G._RH_Events[i]
                end
                _G._RH_Events = {}
                sendBatchWebhook(batchToSend)
                if statusLabel then
                    statusLabel.Text = "Events: " .. hookCount .. " | Pending: 0/" .. BATCH_SIZE .. " (Sent!)"
                end
            end
            
            -- Call original
            return originalFireClient(self, unpack(args))
        end)
        
        addLog("âœ“ Hook installed")
        return true
    end)
    
    if success then
        addLog("âœ“ Hook successful!")
        return true
    else
        addLog("âœ— Hook failed: " .. tostring(err))
        return false
    end
end

local function testOnClientEvent()
    if not remoteEvent then
        addLog("ERROR: RemoteEvent not found!")
        return
    end
    
    addLog("\n=== Testing OnClientEvent ===")
    
    local success, err = pcall(function()
        remoteEvent.OnClientEvent:Connect(function(...)
            hookCount = hookCount + 1
            local args = {...}
            addLog("\n[OnClientEvent #" .. hookCount .. "] Event received!")
            addLog("  Args count: " .. #args)
            
            for i, arg in ipairs(args) do
                local argType = type(arg)
                addLog("  Arg[" .. i .. "]: " .. argType)
                if argType == "string" then
                    addLog("    Value: " .. arg)
                elseif argType == "number" then
                    addLog("    Value: " .. tostring(arg))
                elseif argType == "table" then
                    local keyCount = 0
                    for _ in pairs(arg) do
                        keyCount = keyCount + 1
                    end
                    addLog("    Table with " .. keyCount .. " keys")
                    local shown = 0
                    for k, v in pairs(arg) do
                        if shown < 3 then
                            addLog("      " .. tostring(k) .. " = " .. tostring(v))
                            shown = shown + 1
                        end
                    end
                end
            end
        end)
    end)
    
    if success then
        addLog("âœ“ OnClientEvent connected")
    else
        addLog("âœ— OnClientEvent failed: " .. tostring(err))
    end
end

local findBtn = Instance.new("TextButton")
findBtn.Size = UDim2.new(0, 110, 0, 28)
findBtn.Position = UDim2.new(0.5, -120, 0, 255)
findBtn.BackgroundColor3 = Color3.fromRGB(80, 120, 200)
findBtn.BorderSizePixel = 0
findBtn.Text = "Find Remote"
findBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
findBtn.TextSize = 9
findBtn.Font = Enum.Font.Gotham
findBtn.Parent = f

local hookBtn = Instance.new("TextButton")
hookBtn.Size = UDim2.new(0, 110, 0, 28)
hookBtn.Position = UDim2.new(0.5, 10, 0, 255)
hookBtn.BackgroundColor3 = Color3.fromRGB(200, 100, 50)
hookBtn.BorderSizePixel = 0
hookBtn.Text = "Hook FireClient"
hookBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
hookBtn.TextSize = 9
hookBtn.Font = Enum.Font.Gotham
hookBtn.Parent = f

local testBtn = Instance.new("TextButton")
testBtn.Size = UDim2.new(0, 110, 0, 28)
testBtn.Position = UDim2.new(0.5, -120, 0, 285)
testBtn.BackgroundColor3 = Color3.fromRGB(120, 80, 200)
testBtn.BorderSizePixel = 0
testBtn.Text = "Test OnClientEvent"
testBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
testBtn.TextSize = 9
testBtn.Font = Enum.Font.Gotham
testBtn.Parent = f

local testWebhookBtn = Instance.new("TextButton")
testWebhookBtn.Size = UDim2.new(0, 110, 0, 28)
testWebhookBtn.Position = UDim2.new(0.5, 10, 0, 285)
testWebhookBtn.BackgroundColor3 = Color3.fromRGB(200, 150, 50)
testWebhookBtn.BorderSizePixel = 0
testWebhookBtn.Text = "Test Webhook"
testWebhookBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
testWebhookBtn.TextSize = 9
testWebhookBtn.Font = Enum.Font.Gotham
testWebhookBtn.Parent = f

local sendBatchBtn = Instance.new("TextButton")
sendBatchBtn.Size = UDim2.new(0, 110, 0, 28)
sendBatchBtn.Position = UDim2.new(0.5, -120, 0, 318)
sendBatchBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
sendBatchBtn.BorderSizePixel = 0
sendBatchBtn.Text = "Send Batch Now"
sendBatchBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
sendBatchBtn.TextSize = 9
sendBatchBtn.Font = Enum.Font.Gotham
sendBatchBtn.Parent = f

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 110, 0, 28)
closeBtn.Position = UDim2.new(0.5, 10, 0, 318)
closeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeBtn.BorderSizePixel = 0
closeBtn.Text = "Close/Stop"
closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.TextSize = 10
closeBtn.Font = Enum.Font.GothamBold
closeBtn.Parent = f

local statusLabel = Instance.new("TextLabel")
statusLabel.Size = UDim2.new(0, 360, 0, 20)
statusLabel.Position = UDim2.new(0.5, -180, 0, 260)
statusLabel.BackgroundTransparency = 1
statusLabel.Text = "Events: 0 | Pending: 0"
statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
statusLabel.TextSize = 10
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Parent = f

findBtn.Activated:Connect(function()
    findRemote()
end)

hookBtn.Activated:Connect(function()
    hookFireClient()
end)

testBtn.Activated:Connect(function()
    testOnClientEvent()
end)

testWebhookBtn.Activated:Connect(function()
    addLog("\n=== Testing Webhook ===")
    if not httpLib then
        addLog("ERROR: HTTP library not found!")
        return
    end
    
    local testPayload = {
        content = "ðŸ§ª **Test Webhook**\nThis is a test message from Remote Hook Test v4.0\nTime: " .. os.date("%X")
    }
    local jsonPayload = jsonEncode(testPayload)
    local headers = {["Content-Type"] = "application/json"}
    
    addLog("Sending test webhook...")
    local success, response, status = httpLib(WEBHOOK, "POST", headers, jsonPayload)
    
    if success and (status == 200 or status == 204) then
        addLog("âœ“ Test webhook sent successfully!")
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Webhook Test",
            Text = "Test sent! Check Discord.",
            Duration = 3
        })
    else
        addLog("âœ— Test webhook failed: " .. tostring(status or "error"))
    end
end)

sendBatchBtn.Activated:Connect(function()
    addLog("\n=== Manual Send Batch ===")
    addLog("Hook count: " .. hookCount)
    
    -- Use the simple global storage
    local storedCount = #_G._RH_Events
    addLog("Stored events count: " .. storedCount)
    print("MANUAL SEND: Count = " .. storedCount)
    
    if storedCount > 0 then
        -- Copy all events
        local eventsToSend = {}
        for i = 1, storedCount do
            eventsToSend[i] = _G._RH_Events[i]
        end
        
        addLog("Sending " .. #eventsToSend .. " events...")
        sendBatchWebhook(eventsToSend)
        
        -- Clear storage
        _G._RH_Events = {}
        
        if statusLabel then
            statusLabel.Text = "Events: " .. hookCount .. " | Pending: 0/" .. BATCH_SIZE .. " (Sent!)"
        end
        addLog("Batch sent!")
    else
        addLog("ERROR: No events stored!")
        addLog("Hook fired " .. hookCount .. " times but storage is empty")
    end
end)

closeBtn.Activated:Connect(function()
    addLog("Closing script...")
    -- Unhook if hooked
    if originalFireClient and remoteEvent then
        pcall(function()
            remoteEvent.FireClient = originalFireClient
        end)
        addLog("Unhooked FireClient")
    end
    -- Send any pending events before closing
    local finalCount = #_G._RH_Events
    if finalCount > 0 then
        addLog("Sending final batch (" .. finalCount .. " events)...")
        local finalBatch = {}
        for i = 1, finalCount do
            finalBatch[i] = _G._RH_Events[i]
        end
        sendBatchWebhook(finalBatch)
        task.wait(1)
    end
    -- Close GUI
    pcall(function()
        g:Destroy()
    end)
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Remote Hook Test",
        Text = "Script closed",
        Duration = 3
    })
    -- Stop script execution
    error("Script closed by user")
end)

-- Auto-find on load
task.wait(1)
addLog("HTTP Library: " .. (httpLibName ~= "" and httpLibName or "NOT FOUND"))
findRemote()


